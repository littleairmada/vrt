package vrt_test

import (
	"reflect"
	"testing"

	"github.com/google/gopacket"
	"github.com/google/gopacket/layers"
	"github.com/littleairmada/vrt"
	"github.com/stretchr/testify/assert"
)

// TODO: setup creates/returns a Test Vrt Packet

var testPacketVRT = []byte{
	0x38, 0x5f, 0x00, 0x8a, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x1c, 0x2d, 0x53, 0x4c, 0xff, 0xff,
	0x62, 0x43, 0x8f, 0xfc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x64, 0x69, 0x73, 0x63,
	0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x76,
	0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x33, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x20, 0x6d,
	0x6f, 0x64, 0x65, 0x6c, 0x3d, 0x46, 0x4c, 0x45, 0x58, 0x2d, 0x36, 0x37, 0x30, 0x30, 0x20, 0x73,
	0x65, 0x72, 0x69, 0x61, 0x6c, 0x3d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x2d,
	0x33, 0x33, 0x33, 0x33, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f,
	0x6e, 0x3d, 0x33, 0x2e, 0x32, 0x2e, 0x33, 0x39, 0x2e, 0x33, 0x33, 0x37, 0x34, 0x20, 0x6e, 0x69,
	0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x3d, 0x54, 0x45, 0x53, 0x54, 0x31, 0x2f, 0x48, 0x46, 0x2f,
	0x41, 0x4d, 0x50, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x3d, 0x4e, 0x53, 0x31,
	0x48, 0x20, 0x69, 0x70, 0x3d, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x30, 0x2e, 0x31,
	0x31, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x3d, 0x34, 0x39, 0x39, 0x32, 0x20, 0x73, 0x74, 0x61, 0x74,
	0x75, 0x73, 0x3d, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x75,
	0x73, 0x65, 0x5f, 0x69, 0x70, 0x3d, 0x20, 0x69, 0x6e, 0x75, 0x73, 0x65, 0x5f, 0x68, 0x6f, 0x73,
	0x74, 0x3d, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x64, 0x5f,
	0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x76, 0x33, 0x20, 0x72, 0x61, 0x64, 0x69, 0x6f,
	0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x5f, 0x69, 0x64, 0x3d, 0x30, 0x30, 0x2d, 0x31,
	0x31, 0x2d, 0x32, 0x32, 0x2d, 0x33, 0x33, 0x2d, 0x34, 0x34, 0x2d, 0x35, 0x35, 0x20, 0x72, 0x65,
	0x71, 0x75, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61,
	0x6c, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x3d, 0x30, 0x20, 0x66, 0x70, 0x63, 0x5f,
	0x6d, 0x61, 0x63, 0x3d, 0x20, 0x77, 0x61, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74,
	0x65, 0x64, 0x3d, 0x31, 0x20, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x64, 0x5f, 0x63, 0x6c,
	0x69, 0x65, 0x6e, 0x74, 0x73, 0x3d, 0x32, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c,
	0x65, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x3d, 0x32, 0x20, 0x6d, 0x61, 0x78, 0x5f,
	0x70, 0x61, 0x6e, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x3d, 0x38, 0x20, 0x61, 0x76,
	0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x70, 0x61, 0x6e, 0x61, 0x64, 0x61, 0x70, 0x74,
	0x65, 0x72, 0x73, 0x3d, 0x38, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x73,
	0x3d, 0x38, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x6c, 0x69,
	0x63, 0x65, 0x73, 0x3d, 0x38, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
	0x5f, 0x69, 0x70, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74,
	0x5f, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65,
	0x6e, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69,
	0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
	0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x68, 0x61, 0x6e,
	0x64, 0x6c, 0x65, 0x73, 0x3d, 0x00, 0x00, 0x00,
}

func checkLayers(p gopacket.Packet, want []gopacket.LayerType, t *testing.T) {
	layers := p.Layers()
	t.Log("Checking packet layers, want", want)
	for _, l := range layers {
		t.Logf("  Got layer %v, %d bytes, payload of %d bytes", l.LayerType(),
			len(l.LayerContents()), len(l.LayerPayload()))
	}
	t.Log(p)
	if len(layers) < len(want) {
		t.Errorf("  Number of layers mismatch: got %d want %d", len(layers),
			len(want))
		return
	}
	for i, l := range want {
		if l == gopacket.LayerTypePayload {
			// done matching layers
			return
		}

		if layers[i].LayerType() != l {
			t.Errorf("  Layer %d mismatch: got %v want %v", i,
				layers[i].LayerType(), l)
		}
	}
}

// Tests whether a VRT Layer struct can be serialized into a UDP packet.
func TestVRTSerialization(t *testing.T) {
	test_vrt := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.ExtData,
			C:           true,
			T:           false,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFRealTime,
			PacketCount: 14,
			PacketSize:  6,
		},
		StreamID: 2048,
		ClassID: vrt.ClassID{
			OUI:                  7213,
			PacketClassCode:      21324,
			InformationClassCode: 65535,
		},
		TimestampInt:  1687383639,
		TimestampFrac: 0,
		Payload:       []byte{0x64, 0x69, 0x73, 0x63},
	}

	want := vrt.ExtData
	if want != test_vrt.Header.Type {
		t.Fatalf(`vrt.Header.Type = %q, want match for %#q, nil`, test_vrt.Header.Type, want)
	}

	buf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: false,
	}
	err := test_vrt.SerializeTo(buf, opts)
	if err != nil {
		t.Fatalf(`vrt.SerializeTo failed with %s`, err)
	}
}

// TODO: implement VRT Trailer and check for it's presence
func TestVRTSerializationWithTrailer(t *testing.T) {
	test_vrt := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.ExtData,
			C:           true,
			T:           true,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFRealTime,
			PacketCount: 14,
			PacketSize:  7,
		},
		StreamID: 2048,
		ClassID: vrt.ClassID{
			OUI:                  7213,
			PacketClassCode:      21324,
			InformationClassCode: 65535,
		},
		TimestampInt:  1687383639,
		TimestampFrac: 0,
		Payload:       []byte{0x64, 0x69, 0x73, 0x63},
	}

	want := vrt.ExtData
	if want != test_vrt.Header.Type {
		t.Fatalf(`vrt.Header.Type = %q, want match for %#q, nil`, test_vrt.Header.Type, want)
	}

	buf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: false,
	}
	err := test_vrt.SerializeTo(buf, opts)
	if err != nil {
		t.Fatalf(`vrt.SerializeTo failed with %s`, err)
	}

	// fmt.Println("buf: ", buf)
}

// Tests decoding the various VRT packet header fields
// func TestVRTDecodeHeader(t *testing.T) {
// 	fmt.Println("TODO")
// }

// func testVRTEqual(t *testing.T, vrt1, vrt2 *VRT) {
// 	if vrt1.Header.Type != vrt2.Header.Type {
// 		t.Errorf("expected Header.Type=%d, got %d", vrt1.Header.Type, vrt2.Header.Type)
// 	}
// 	if vrt1.Header.C != vrt2.Header.C {
// 		t.Errorf("expected Header.C=%t, got %t", vrt1.Header.C, vrt2.Header.C)
// 	}
// 	if vrt1.Header.T != vrt2.Header.T {
// 		t.Errorf("expected Header.T=%t, got %t", vrt1.Header.T, vrt2.Header.T)
// 	}
// 	if vrt1.Header.TSI != vrt2.Header.TSI {
// 		t.Errorf("expected Header.TSI=%v, got %v", vrt1.Header.TSI, vrt2.Header.TSI)
// 	}
// 	if vrt1.Header.TSF != vrt2.Header.TSF {
// 		t.Errorf("expected Header.TSF=%v, got %v", vrt1.Header.TSF, vrt2.Header.TSF)
// 	}
// 	if vrt1.Header.PacketCount != vrt2.Header.PacketCount {
// 		t.Errorf("expected Header.PacketCount=%v, got %v", vrt1.Header.PacketCount, vrt2.Header.PacketCount)
// 	}
// 	if vrt1.Header.PacketSize != vrt2.Header.PacketSize {
// 		t.Errorf("expected Header.PacketSize=%v, got %v", vrt1.Header.PacketSize, vrt2.Header.PacketSize)
// 	}
// 	if !bytes.Equal(vrt1.Payload, vrt2.Payload) {
// 		t.Errorf("expected Payload=%v, got %v", vrt1.Payload, vrt2.Payload)
// 	}
// 	if len(vrt1.Payload) != len(vrt2.Payload) {
// 		t.Errorf("expected %d Payload, got %d", len(vrt1.Payload), len(vrt2.Payload))
// 	}
// }

func TestVRTLayers(t *testing.T) {
	test_vrt := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.ExtData,
			C:           true,
			T:           false,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFRealTime,
			PacketCount: 14,
			PacketSize:  6,
		},
		StreamID: 2048,
		ClassID: vrt.ClassID{
			OUI:                  7213,
			PacketClassCode:      21324,
			InformationClassCode: 65535,
		},
		TimestampInt:  1687383639,
		TimestampFrac: 0,
		Payload:       []byte{0x64, 0x69, 0x73, 0x63},
	}

	buf := gopacket.NewSerializeBuffer()
	opts := gopacket.SerializeOptions{
		FixLengths:       true,
		ComputeChecksums: false,
	}
	err := test_vrt.SerializeTo(buf, opts)
	if err != nil {
		t.Fatalf(`vrt.SerializeTo failed with %s`, err)
	}

	result := test_vrt.LayerType()
	if result != vrt.LayerTypeVRT {
		t.Errorf("LayerType results was incorrect, got: #{result}, want: #{vrt.LayerTypeVRT}.")
	}

	result = test_vrt.NextLayerType()
	if result != gopacket.LayerTypePayload {
		t.Errorf("LayerType results was incorrect, got: #{result}, want: #{gopacket.LayerTypePayload}.")
	}

	// LayerContents()
	layer_contents_result := test_vrt.LayerContents()
	assert.IsType(t, []byte{}, layer_contents_result, "VRT Packet LayerContents must be byte array")
	assert.Equal(t, len(buf.Bytes()), len(layer_contents_result), "VRT Packet LayerContents length must match entire VRT packet size")

	// LayerPayload()
	layer_payload_result := test_vrt.LayerPayload()
	assert.IsType(t, []byte{}, layer_payload_result, "VRT Packet LayerPayload must be byte array")
	assert.Equal(t, 4, len(layer_payload_result), "VRT Packet LayerPayload length must match test payload length")

	// CanDecode()
	can_decode_result := test_vrt.CanDecode()
	if can_decode_result != vrt.LayerTypeVRT {
		t.Errorf("LayerType results was incorrect, got: #{can_decode_result}, want: #{vrt.LayerTypeVRT}.")
	}

}

func TestPacketVRT(t *testing.T) {
	p := gopacket.NewPacket(testPacketVRT, vrt.LayerTypeVRT, gopacket.Default)

	wantLayers := []gopacket.LayerType{vrt.LayerTypeVRT}
	checkLayers(p, wantLayers, t)

	if got, ok := p.Layer(vrt.LayerTypeVRT).(*vrt.VRT); ok {
		want := &vrt.VRT{
			BaseLayer: layers.BaseLayer{Contents: testPacketVRT[:]},
			Header: vrt.Header{
				Type:        vrt.ExtDataWithStream,
				C:           true,
				T:           false,
				TSI:         vrt.TSIUTC,
				TSF:         vrt.TSFSampleCount,
				PacketCount: 15,
				PacketSize:  138,
			},
			StreamID: 0x800,
			ClassID: vrt.ClassID{
				OUI:                  0x1c2d,
				PacketClassCode:      0x534c,
				InformationClassCode: 0xffff,
			},
			TimestampInt:  0x62438ffc,
			TimestampFrac: 0,
			Payload:       []uint8{0x64, 0x69, 0x73, 0x63, 0x6f, 0x76, 0x65, 0x72, 0x79, 0x5f, 0x70, 0x72, 0x6f, 0x74, 0x6f, 0x63, 0x6f, 0x6c, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x33, 0x2e, 0x30, 0x2e, 0x30, 0x2e, 0x31, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x6c, 0x3d, 0x46, 0x4c, 0x45, 0x58, 0x2d, 0x36, 0x37, 0x30, 0x30, 0x20, 0x73, 0x65, 0x72, 0x69, 0x61, 0x6c, 0x3d, 0x31, 0x31, 0x31, 0x31, 0x2d, 0x32, 0x32, 0x32, 0x32, 0x2d, 0x33, 0x33, 0x33, 0x33, 0x2d, 0x34, 0x34, 0x34, 0x34, 0x20, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x33, 0x2e, 0x32, 0x2e, 0x33, 0x39, 0x2e, 0x33, 0x33, 0x37, 0x34, 0x20, 0x6e, 0x69, 0x63, 0x6b, 0x6e, 0x61, 0x6d, 0x65, 0x3d, 0x54, 0x45, 0x53, 0x54, 0x31, 0x2f, 0x48, 0x46, 0x2f, 0x41, 0x4d, 0x50, 0x20, 0x63, 0x61, 0x6c, 0x6c, 0x73, 0x69, 0x67, 0x6e, 0x3d, 0x4e, 0x53, 0x31, 0x48, 0x20, 0x69, 0x70, 0x3d, 0x31, 0x39, 0x32, 0x2e, 0x31, 0x36, 0x38, 0x2e, 0x30, 0x2e, 0x31, 0x31, 0x20, 0x70, 0x6f, 0x72, 0x74, 0x3d, 0x34, 0x39, 0x39, 0x32, 0x20, 0x73, 0x74, 0x61, 0x74, 0x75, 0x73, 0x3d, 0x41, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x20, 0x69, 0x6e, 0x75, 0x73, 0x65, 0x5f, 0x69, 0x70, 0x3d, 0x20, 0x69, 0x6e, 0x75, 0x73, 0x65, 0x5f, 0x68, 0x6f, 0x73, 0x74, 0x3d, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x64, 0x5f, 0x76, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x3d, 0x76, 0x33, 0x20, 0x72, 0x61, 0x64, 0x69, 0x6f, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x5f, 0x69, 0x64, 0x3d, 0x30, 0x30, 0x2d, 0x31, 0x31, 0x2d, 0x32, 0x32, 0x2d, 0x33, 0x33, 0x2d, 0x34, 0x34, 0x2d, 0x35, 0x35, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x73, 0x5f, 0x61, 0x64, 0x64, 0x69, 0x74, 0x69, 0x6f, 0x6e, 0x61, 0x6c, 0x5f, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x3d, 0x30, 0x20, 0x66, 0x70, 0x63, 0x5f, 0x6d, 0x61, 0x63, 0x3d, 0x20, 0x77, 0x61, 0x6e, 0x5f, 0x63, 0x6f, 0x6e, 0x6e, 0x65, 0x63, 0x74, 0x65, 0x64, 0x3d, 0x31, 0x20, 0x6c, 0x69, 0x63, 0x65, 0x6e, 0x73, 0x65, 0x64, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x3d, 0x32, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x73, 0x3d, 0x32, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x70, 0x61, 0x6e, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x3d, 0x38, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x70, 0x61, 0x6e, 0x61, 0x64, 0x61, 0x70, 0x74, 0x65, 0x72, 0x73, 0x3d, 0x38, 0x20, 0x6d, 0x61, 0x78, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x73, 0x3d, 0x38, 0x20, 0x61, 0x76, 0x61, 0x69, 0x6c, 0x61, 0x62, 0x6c, 0x65, 0x5f, 0x73, 0x6c, 0x69, 0x63, 0x65, 0x73, 0x3d, 0x38, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x69, 0x70, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x68, 0x6f, 0x73, 0x74, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61, 0x6d, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x73, 0x74, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x3d, 0x20, 0x67, 0x75, 0x69, 0x5f, 0x63, 0x6c, 0x69, 0x65, 0x6e, 0x74, 0x5f, 0x68, 0x61, 0x6e, 0x64, 0x6c, 0x65, 0x73, 0x3d, 0x00, 0x00, 0x00},
		}

		if !reflect.DeepEqual(got, want) {
			t.Errorf("VRT packet processing failed:\ngot  :\n%#v\n\nwant :\n%#v\n\n", got, want)
		}
	}
}

// ValidateVrtPacketSize with various VRT Packet Types
func TestValidateVrtPacketSize(t *testing.T) {
	// Set defaults for test
	// DefaultVrtClassID := vrt.ClassID{
	// 	OUI:                  7213,
	// 	PacketClassCode:      21324,
	// 	InformationClassCode: 65535,
	// }

	// Test Malformed VRT Packet
	test_vrt_malformed := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.IFData,
			C:           false,
			T:           true,
			TSI:         vrt.TSINone,
			TSF:         vrt.TSFNone,
			PacketCount: 14,
			PacketSize:  2,
		},
		Payload: []byte{0x01, 0x02, 0x03, 0x04},
	}
	test_vrt_malformed_total_packet_size := uint32(4 * test_vrt_malformed.Header.PacketSize)
	_, _, err := vrt.ValidateVrtPacketSize(test_vrt_malformed.Header, test_vrt_malformed_total_packet_size)
	assert.EqualError(t, err, "malformed VRT packet")

	// IFData with Trailer
	test_vrt_ifdata := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.IFData,
			C:           false,
			T:           true,
			TSI:         vrt.TSINone,
			TSF:         vrt.TSFNone,
			PacketCount: 14,
			PacketSize:  3,
		},
		Payload: []byte{0x01, 0x02, 0x03, 0x04},
	}
	test_vrt_ifdata_total_packet_size := uint32(4 * test_vrt_ifdata.Header.PacketSize)

	headerSize, minimumWords, err := vrt.ValidateVrtPacketSize(test_vrt_ifdata.Header, test_vrt_ifdata_total_packet_size)
	assert.Nil(t, err, "The IFData packet with Trailer ValidateVrtPacketSize error should be nil")
	assert.Equal(t, uint16(test_vrt_ifdata_total_packet_size/4), headerSize, "The IFData packet with Trailer total packet size should match")
	assert.Equal(t, uint32(3), minimumWords, "The IFData packet with Trailer minimum words should match")

	// IFDataWithStream
	test_vrt_ifdatawithstream := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.IFDataWithStream,
			C:           false,
			T:           false,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFNone,
			PacketCount: 14,
			PacketSize:  4,
		},
		StreamID:     2048,
		TimestampInt: 1687383639,
		Payload:      []byte{0x01, 0x02, 0x03, 0x04},
	}
	test_vrt_ifdatawithstream_total_packet_size := uint32(4 * test_vrt_ifdatawithstream.Header.PacketSize)

	headerSize, minimumWords, err = vrt.ValidateVrtPacketSize(test_vrt_ifdatawithstream.Header, test_vrt_ifdatawithstream_total_packet_size)
	assert.Nil(t, err, "The IfDataWithStream packet ValidateVrtPacketSize error should be nil")
	assert.Equal(t, uint16(test_vrt_ifdatawithstream_total_packet_size/4), headerSize, "The IfDataWithStream packet total packet size should match")
	assert.Equal(t, uint32(4), minimumWords, "The IfDataWithStream packet minimum words should match")

	// ExtData
	test_vrt_extdata := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.ExtData,
			C:           false,
			T:           false,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFNone,
			PacketCount: 14,
			PacketSize:  3,
		},
		StreamID:     2048,
		TimestampInt: 1687383639,
		Payload:      []byte{0x01, 0x02, 0x03, 0x04},
	}
	test_vrt_extdata_total_packet_size := uint32(4 * test_vrt_extdata.Header.PacketSize)

	headerSize, minimumWords, err = vrt.ValidateVrtPacketSize(test_vrt_extdata.Header, test_vrt_extdata_total_packet_size)
	assert.Nil(t, err, "The ExtData packet ValidateVrtPacketSize error should be nil")
	assert.Equal(t, uint16(test_vrt_extdata_total_packet_size/4), headerSize, "The ExtData packet total packet size should match")
	assert.Equal(t, uint32(3), minimumWords, "The ExtData packet minimum words should match")

	// ExtDataWithStream
	test_vrt_extdatawithstream := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.ExtDataWithStream,
			C:           false,
			T:           false,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFNone,
			PacketCount: 14,
			PacketSize:  4,
		},
		StreamID:     2048,
		TimestampInt: 1687383639,
		Payload:      []byte{0x01, 0x02, 0x03, 0x04},
	}
	test_vrt_extdatawithstream_total_packet_size := uint32(4 * test_vrt_extdatawithstream.Header.PacketSize)

	headerSize, minimumWords, err = vrt.ValidateVrtPacketSize(test_vrt_extdatawithstream.Header, test_vrt_extdatawithstream_total_packet_size)
	assert.Nil(t, err, "The ExtDataWithStream packet ValidateVrtPacketSize error should be nil")
	assert.Equal(t, uint16(test_vrt_extdatawithstream_total_packet_size/4), headerSize, "The ExtDataWithStream packet total packet size should match")
	assert.Equal(t, uint32(4), minimumWords, "The ExtDataWithStream packet minimum words should match")

	// IFContext
	test_vrt_ifcontext := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.IFContext,
			C:           false,
			T:           false,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFNone,
			PacketCount: 14,
			PacketSize:  4,
		},
		StreamID:     2048,
		TimestampInt: 1687383639,
		Payload:      []byte{0x01, 0x02, 0x03, 0x04},
	}
	test_vrt_ifcontext_total_packet_size := uint32(4 * test_vrt_ifcontext.Header.PacketSize)

	headerSize, minimumWords, err = vrt.ValidateVrtPacketSize(test_vrt_ifcontext.Header, test_vrt_ifcontext_total_packet_size)
	assert.Nil(t, err, "The IFContext packet ValidateVrtPacketSize error should be nil")
	assert.Equal(t, uint16(test_vrt_ifcontext_total_packet_size/4), headerSize, "The IFContext packet total packet size should match")
	assert.Equal(t, uint32(4), minimumWords, "The IFContext packet minimum words should match")

	// ExtContext
	test_vrt_extcontext := &vrt.VRT{
		Header: vrt.Header{
			Type:        vrt.ExtContext,
			C:           false,
			T:           false,
			TSI:         vrt.TSIUTC,
			TSF:         vrt.TSFNone,
			PacketCount: 14,
			PacketSize:  4,
		},
		StreamID:     2048,
		TimestampInt: 1687383639,
		Payload:      []byte{0x01, 0x02, 0x03, 0x04},
	}
	test_vrt_extcontext_total_packet_size := uint32(4 * test_vrt_extcontext.Header.PacketSize)

	headerSize, minimumWords, err = vrt.ValidateVrtPacketSize(test_vrt_extcontext.Header, test_vrt_extcontext_total_packet_size)
	assert.Nil(t, err, "The ExtContext packet ValidateVrtPacketSize error should be nil")
	assert.Equal(t, uint16(test_vrt_extcontext_total_packet_size/4), headerSize, "The ExtContext packet total packet size should match")
	assert.Equal(t, uint32(4), minimumWords, "The ExtContext packet minimum words should match")
}

// TODO: Test DecodeFromBytes with Malformed VRT Packet
// func TestDecodeFromBytesPacketMalformed(t *testing.T) {
// }

// TODO: Test DecodeFromBytes with Too Small VRT Packet
// func TestDecodeFromBytesPacketTooSmall(t *testing.T) {
// }

// TODO: Test DecodeFromBytes with VRT Packet Needing Extra Payload Padding
// func TestDecodeFromBytesAddExtraPadding(t *testing.T) {
// }
